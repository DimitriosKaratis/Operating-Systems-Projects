For example1.c:
i) We first need to compile the program using gcc and run the generated executable.

ii) gcc example1.c -o example1 to compile and ./example1 to run. The output in my case is:
Parent Process: PID = 3205561, Created Child PID = 3205562
Child Process: PID = 3205562, Parent PID = 3205561
total 48
-rwxrwxr-x 1 karatisd karatisd 17048 Dec 21 21:33 example1
-rw-rw-r-- 1 karatisd karatisd   855 Dec 19 13:25 example1.c
-rw-rw-r-- 1 karatisd karatisd   347 Dec 19 13:25 example2.c
-rw-rw-r-- 1 karatisd karatisd   643 Dec 19 13:25 example3.c
-rw-rw-r-- 1 karatisd karatisd   670 Dec 19 13:25 example4.c
-rw-rw-r-- 1 karatisd karatisd  1622 Dec 19 13:25 example5.c
-rw-rw-r-- 1 karatisd karatisd  1558 Dec 19 13:25 lab04.tar.gz
-rw-rw-r-- 1 karatisd karatisd   564 Dec 19 13:25 Makefile
Parent Process: Child has terminated.

iii) The program demonstrates process creation and management in C using fork() and execlp(). The fork() system call creates a new child process. The parent process prints its own PID and the PID of the child, then waits for the child to finish using wait(). Meanwhile, the child process executes the ls -l command using execlp(), which replaces the childâ€™s memory with the new program. If execlp() fails, the child prints an error and exits. Once the child process completes, the parent confirms its termination.


For example2.c
i) We first need to compile the program using gcc and run the generated executable.

ii) gcc example2.c -o example2 to compile and ./example2 to run. The output in my case is:
Current Process ID (PID): 3205757
Parent Process ID (PPID): 3205521

iii) The program retrieves and displays the process ID (PID) of the current process and the parent process ID (PPID) using getpid() and getppid(), respectively. The getpid() function returns the PID of the process executing the code, while getppid() returns the PID of its parent.


For example3.c
i) We first need to compile the program using gcc and run the generated executable.

ii) gcc example2.c -o example3 to compile and ./example3 to run. The output in my case is:
Process ID: 3205813
Press Ctrl+C to trigger SIGINT.
Running... Press Ctrl+C to exit.
Running... Press Ctrl+C to exit.
Running... Press Ctrl+C to exit.
Running... Press Ctrl+C to exit.
^C
Caught signal 2 (SIGINT). Exiting gracefully...

iii) The program demonstrates handling the SIGINT signal, typically generated by pressing Ctrl+C in the terminal. It defines a custom signal handler function sigint_handler() that gets executed when the SIGINT signal is caught. Inside the handler, it prints a message indicating the signal has been caught and then exits the program gracefully using exit(0).


For example4.c
i) We first need to compile the program using gcc and run the generated executable.

ii) gcc example2.c -o example4 to compile and ./example4 to run. The output in my case is: 
Process ID: 3205834
Press Ctrl+C to attempt to send SIGINT.
Running... Try pressing Ctrl+C.
Running... Try pressing Ctrl+C.
Running... Try pressing Ctrl+C.
^C
Received SIGINT (signal 2), but ignoring it.
Running... Try pressing Ctrl+C.
Running... Try pressing Ctrl+C.
^C
Received SIGINT (signal 2), but ignoring it.
Running... Try pressing Ctrl+C.
^C
Received SIGINT (signal 2), but ignoring it.
Running... Try pressing Ctrl+C.

iii) This program catches the SIGINT signal (usually triggered by pressing Ctrl+C) and ignores it. When SIGINT is received, the program prints a message but keeps running instead of terminating. It continuously prints a message every 2 seconds, and pressing Ctrl+C just triggers the handler without stopping the program.


For example5.c
i) We first need to compile the program using gcc and run the generated executable.

ii) gcc example2.c -o example5 to compile and ./example5 to run. The output in my case is:
Parent process ID: 3205853. Child PID: 3205854
Child process ID: 3205854. Waiting for SIGUSR1...
Parent sending SIGUSR1 to child.
Child received SIGUSR1 (signal 10).
Parent sending SIGTERM to child.
Child process terminated.

iii) This program demonstrates signal communication between a parent and child process. The parent creates a child using fork(), then waits 3 seconds before sending a SIGUSR1 signal to the child. The child has a signal handler for SIGUSR1, which prints a message when received. After the child handles the signal, the parent sends a SIGTERM signal to terminate the child, waits for it to finish, and then exits. The child remains alive in an infinite loop, waiting for signals until terminated by the parent.
